---
layout: default
title: Часть 1. Начало
parent: Подготовка запросов
nav_order: 1
---
# Часть 1. Начало разработки модуля обработки заданий и подготовки запросов
{: .no_toc }  
В [части 5. Разработка mpg](./PGConnection5.md) мы закончили разрабатывать прототип модуля Выполнения звпросов к PostgreSQL и обсудили модульную систему. Одной из частей такой комплексной модульной системы является модуль Обработки заданий и подготовки запросов, который подготавливает запрос и помещает его в очередь запросов модуля Выполнения запросов.  
  
Сейчас рассмотрим и разработаем прототип модуля Подготовки запросов (далее - Модуль или Подсистема). Когда в тексте встречается термин Программа, то имеется ввиду целостная система, объединяющая все модули.
## Содержание
{: .no_toc }  
1. TOC
{:toc}

# Общие положения 
Что Модуль дожен делать:
- Модуль должен предоставлять конечному пользователю возможность самому создавать и изменять структуру данных. Эта структура данных является нелинейной, т.е. не просто набор столбцов какой-то сущности, но и набор связей между сущностями.  
- Возможность создавать и изменять структуру данных должна быть простой и понятной.  
- Структура создаваемой БД хранится рядом с данными в той же БД.  
- Модуль должен предоставлять конечному пользователю возможность добавлять и изменять данные, соответствующие указанной структуре.
- Ну и, Модуль должен позволять делать выборки данных. Здесь пока затрудняемся выдвинуть требование простоты и понятности.
  

# Структуры данных и отношения
Сложность структуры ланных определяется отношениями между сущностями структуры. Сущности структуры - это элементы предметной области, которую мы автоматизируем. В результате опыта работы в разных предметных областях мы попытались выделить несколько, наиболее часто встречающихся отношений между сущностями. Этот список отношений не полный, и кончно же будет расширяться с ростом системы.  
Отношения также влияют на представление предметной области (грубо сказать - интерфейс пользователя). Конечно же нельзя интерфейс пользователя проецировать на структуру базы данных. Мы не будем этого делать, просто наглядное представление порой бывает лучше тысячи слов.  В каждом разделе, описывая примеры, будем показывать как это отнощение воспринимается с точки зрения предметной области.
  
Далее рассмотрим отношения и примеры их использования.  

## 1. Ссылка
Далее выделены две ссылки, которые, с точки зрения системы, являются абсолютно идентичными, но различаются с точки зрения предметной области.
### 1.1. Простая ссылка
Структура реляционных таблиц может быть следующей:  
![ref](img/ref.png)  
В этом примере показана простая ссылка: ```Роль пользователя``` является ролью, настроенной для организации (ссылается на ```Роль организации```), которой принадлежит пользователь. Здесь показана ситуация, когда у сущности Роль пользователя есть два ключевых поля ```id``` и ```userId``` . Также у Роли организации есть два ключевых поля ```id``` и ```entityId```.   
**PK** - primary key (первичный ключ): используется для указания полей, идентифицирующих запись.  
**FK** - foreign key (внешний ключ): используется для указания идентифицирующих полей записи из другой таблицы, на которую ссылаемся.   
Эти ключи обеспечивают целостность базы данных. Т.е. СУБД (в нашем случае PostgreSQL) сама отслеживает, чтобы не было ссылок на запись, отсутствующую в другой таблице.
  
Вот как видится это с точки зрения **предметной области**:  
![ref DO](img/ref_DO.png)  
  
**Возможные выборки**:
- показать всех пользователей, обладающих конкретной ролью организации.
  
### 1.2. Ссылка на справочник
Структура реляционных таблиц может быть следующей:  
![ref ref](img/ref_ref.png)  
В этом примере показана простая ссылка: ```Документ``` имеет вид Приказ из списка ```Вид документа```. 
  
Вот как видится это с точки зрения **предметной области**:  
![ref ref DO](img/ref_ref_DO.png)  
  
**Возможные выборки**:
- показать все документы этого вида.
## 2. Агрегация
Далее выделены два вида агрегации.
### 2.1. Простая агрегация
Структура реляционных таблиц может быть следующей:  
![agg](img/agg.png)  
На схеме в качестве примера показаны две простые агрегации.  
Вот как видится это с точки зрения **предметной области**:  
![agg DO](img/agg_DO.png)  
  
**Возможные выборки**:
- показать все версии этого продукта;
- показать все подсистемы этого продукта.  
  
### 2.2. Агрегация с выбором
Агрегация с выбором используется, когда сущность может быть агрегирована в разные сущности.  
В нотации UML это выглядит так:  
![agg 2 UML](img/agg2_uml.png)  
  
Структура реляционных таблиц может быть следующей:  
![agg 2 rel](img/agg2_rel.png)  
  
В **предметной области** это будет выглядеть как простая агрегация.  
  
**Возможные выборки**:
- выбрать все документы, удостоверяющие право собственности по зданию "такому-то";
- выбрать все документы, удостоверяющие право собственности по земельному участку "такому-то";
- выбрать все документы на земельные участки и здания по конкретному собственнику.  
   
## 3. Множественные ссылки
Множественные ссылки имеют схожую структуру таблиц. Отличается только то, как это видится из предметной области
### 3.1. Группа ссылок на объекты одного класса
Группа ссылок это несколько ссылок. Мы можем объединить их в группу, потому-что ссылаемся на объекты одного класса.  
Структура реляционных таблиц может быть следующей:  
![multi](img/multi.png)  
Здесь специальная сущность агрегируется в сущность Пользователь и из нее указывается ссылка на сущность Интерес.

Вот как видится это с точки зрения **предметной области**:  
![multi DO](img/multi_DO.png)  
  
**Возможные выборки**:
- выбрать все интересы пользователя;
- выбрать всех пользователей по заданному интересу.
    
### 3.2. Именованная группа ссылок на объекты одного класса
Именованная группа ссылок это то же самое, что и просто группа ссылок, только агрегируемая сущность  имеет название. Эту конструкцию лучше собирать "руками", т.е. в структуре таблиц создать агрегацию и добавить ссылку. Хотя, возможно, мы реализуем это отношение как одно.  
Структура реляционных таблиц может быть следующей:  
![multi2](img/multi2.png)  
Здесь именованная сущность Товар по акции агрегируется в сущность Торговый отдел и из нее указывается ссылка на сущность Товар.

Вот как видится это с точки зрения **предметной области**:  
![multi2 DO](img/multi2_DO.png)  
  
**Возможные выборки**:
- выбрать все акционные товары этого отдела;
- выбрать все отделы, которые продают данный товар по акции.  
  
### 3.3. Двухсторонняя группа ссылок
Двухсторонняя группа ссылок похожа на группу ссылок на объекты одного класса, только можно ссылаться как из ссылающегося объекта, так и из ссылаемого объекта.    
Структура реляционных таблиц может быть следующей:  
![multi3](img/multi3.png)  
Здесь специальная сущность агрегируется в сущность Пользователь и агрегируется в сущность Группа. Таким образом, имеем Пользователя, имеющего группу ссылок на Группу, и Группу, имеющую группу ссылок на Пользователя.

Вот как видится это с точки зрения **предметной области**:  
![multi2 DO](img/multi3_DO.png)  
  
**Возможные выборки**:
- выбрать все группы пользователя;
- выбрать всех пользователей группы.  
  
## 4. Наследование
### 4.1. Наследование в стиле ООП
Наследование мы понимаем в смысле ООП, где сущность одного класса (Наследник) расширяет свойства, отношения и методы сущности другого класса (Родителя).  
Если какая-то сущность ссылается на Родителя, то вместо Родителя может быть подставлен любой Наследник.
Если Родитель агрегируется в какую-то сущность, то Наследник, по умолчанию, не агрегируется в эту сущность. Агрегацию нужно задать вручную.
  
Структура реляционных таблиц может быть следующей:  
![inherit](img/inherit.png)  
Здесь сущность Акт сдачи-приемки наследует свойства класса Документ и расширяет его двумя дополнительными свойствами zakazchik и ispolnitel.
  
Вот как видится это с точки зрения **предметной области**:  
![inherit DO](img/inherit_DO.png)  
  
**Возможные выборки**:
- выбрать все документы, включая наследников;
- выбрать все акты сдачи приемки. 
